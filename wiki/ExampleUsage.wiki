#labels Featured
Examples 

= Usage =

Import the jar file (memcachefy-1.0.0.jar) into the _classpath_ of your project. In case you are a Maven user you can add the following dependency:

{{{
    <dependency>
        <groupId>br.com.neppo</groupId>
        <artifactId>memcachefy</artifactId>
        <version>1.0.0</version>
     </dependency>
}}}

_*Note*: As of now Memcachefy dependency is still not deployed into a public maven repository. You can install it into your local repository by manually downloading the jar and executing the command:_

{{{
    mvn install:install-file -Dfile=memcachefy-1.0.0 -DgroupId=br.com.neppo \ 
    -DartifactId=memcachefy -Dversion=1.0.0 -Dpackaging=jar
}}}

= Configuring the cache interceptor =

By default, it will try to read a configuration file named "cache-manager.properties" in the classpath.

Example:
{{{
## file: cache-manager.properties

cache.entry.ttl=60
cache.type=MEMCACHED
#cache.initialMaxEntries=5000 ## may be specified if cache.type == ONHEAP
memcached.hosts=host1\:11211, host2\:11211 
memcached.transcoder=NONE

}}}

When using the [http://memcachefy.googlecode.com/svn/trunk/javadoc/com/googlecode/memcachefy/CacheProxy.html CacheProxy] you can supply new instances of the proxy with custom cache objects:

{{{
    CacheManager cacheManager = CacheManagerBuilder.newBuilder()....build();

    Cache<String, Object> cache = cacheManager.getCache("test");
    Action action = (Action) CacheProxy.newInstance(new MyAction(), cache);

}}}

= Spring integration =

You may want to use the {{{FactoryBean}}} interface for creating instances of [http://memcachefy.googlecode.com/svn/trunk/javadoc/com/googlecode/memcachefy/Cache.html Cache] for integration with Spring:

{{{
	public class CacheBean implements FactoryBean<Cache> {

		private String host;
		private int port;

		public Cache getObject() throws Exception {
			return CacheManagerBuilder.newBuilder().
					setCacheType(CacheType.MEMCACHED).
					setMemcachedHosts(host+":"+port).
					setDefaultTtl(120).build().getCache("cache");
		}

		public Class<? extends Cache> getObjectType() {
			return Cache.class;
		}

		public boolean isSingleton() {
			return true;
		}

		public void setHost(String host) {
			this.host = host;
		}

		public void setPort(int port) {
			this.port = port;
		}
	}

}}}

Then add the bean definition into the spring context configuration file:

{{{
    <beans ...> 
        <bean name="cacheBean" class="CacheBean">
            <property name="port" value="11211"/>
            <property name="host" value="localhost"/>
        </bean>
    </beans>
}}}


= Intercepting without annotations =

If for some reason you are not able to annotate in the methods of the class you want to enable caching, you can do the follow:
{{{
    interface ServiceInterface {
        List<String> someMethod(String str);
        String otherMethod(int a, int b);
    }
    ...
    //Create a map with the cache options
    Map<String, CacheInfo> infoMap = new HashMap<String, CacheInfo>();
    infoMap.put("someMethod", new CacheInfo(60/*ttl*/));
    infoMap.put("otherMethod", new CacheInfo(120/*ttl*/));

   // create the proxy passing the cache options
   ServiceInterface service = (ServiceInterface) CacheProxy.newInstance(new MyServiceInterfaceImpl(), infoMap);

}}}


= Using serializers = 

When creating a cache object backed by Memcached it will be using the [http://code.google.com/p/kryo/ Kryo] serializer by default. You can use other serializers as JAXB or even disable the use of non-native serialization (in that case you _*must*_ have all your classes implementing Serializable).

{{{
    // Using JAXB for serializing the data
    // In this case you have to supply it with the JAXBContext, adding all the classes being cached by the API
    CacheManager cacheManager = CacheManagerBuilder.newBuilder().
				setCacheType(CacheType.MEMCACHED).
				setCacheTranscoder(CacheTranscoder.JAXB).
				setJaxbContext(JAXBContext.newInstance(new Class[]{CacheWrapper.class, Dummy.class})).
				setMemcachedHosts("localhost:11211").
				setDefaultTtl(120).build();

    // Disabling other serializers
    CacheManager cacheManager = CacheManagerBuilder.newBuilder().
				setCacheType(CacheType.MEMCACHED).
				setCacheTranscoder(CacheTranscoder.NONE).
				setMemcachedHosts("localhost:11211").
				setDefaultTtl(120).build();
}}}

= Caching options =

There are some caching options that might help you increasing the efficiency of the cache.
In the example below it's been enabled the option {{{enableMinCacheHitVerification}}} which will permanently disable caching for the given method if the cache hit _ratio_ is less than 40% of the total calls to the method after 300 calls.
{{{
    @Cacheable(ttl = 60, enableMinCacheHitVerification = true,
                         minCacheHitRatioRequired = 0.40, 
                         minCacheHitRatioCounting = 300)
    @Override
    public List<SomeObject> findSomeObject(String query) {
    ...

}}}

In the example below negative caching is enabled for the given method.
_*Note:* Enabling this option can be harmful if you don't know exactly the impacts of caching null results for your business rules._
{{{
    @Cacheable(ttl = 400, negativeCache = true)
    @Override
    public List<Contact> findContacts(String name) {
    ...

}}}